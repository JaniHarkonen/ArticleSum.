import ArticleContainer from "./ArticleContainer";
import TagContainer from "./TagContainer";

import { editConfig } from "../../utils/config";

const fs = window.require("fs");

/**
 * Creates a JSON of a workspace that holds the follwing fields:
 * - `id-counter` which keeps track of the next identifier number 
 * that will be generated, the IDs unique numbers assigned to all 
 * items stored in the `.asum`-file
 * - `workspace-name` which holds the name of the workspace
 * - `articles` which holds a JSON of the articles of the workspace
 * paired with their IDs
 * - `tags` which holds a JSON of the articles of the workspace
 * paired with their IDs
 * 
 * At least the ID counter value as well as the workspace name must 
 * be provided to construct a workspace JSON.
 * 
 * @param {Number} counter The next unique identifier number that 
 * will be generated by the `WorkspaceManager`.
 * @param {String} name The name of the workspace that will be 
 * displayed in the header of the application (also the name of 
 * the workspace file).
 * @param {JSON} articles Optional, a JSON containing the articles
 * of the workspace (by default: {}).
 * @param {JSON} tags Optional, a JSON containing the tags of the 
 * workspace (by default: {}).
 * 
 * @returns A JSON representing the workspace.
 */
export const Workspace = (counter, name, articles, tags) => {
  return {
    "id-counter": counter,
    "workspace-name": name,
    "articles": articles || {},
    "tags": tags || {}
  };
};

/**
 * Manager class that keeps track of the model of a workspace. 
 * This manager provides an interface to the workspace as well as
 * functionalities for creating, opening and closing workspaces.
 * 
 * When a workspace is opened, its JSON is read from a given `.asum`-
 * file and parsed into a state held by the workspace manager. This 
 * state includes the name of the workspace, the next ID counter 
 * number, the file path of the workspace as well as the article and 
 * tag containers which hold the contents of the workspace. As of now, 
 * the entire JSON is read into memory which may cause performance 
 * issues when the database grows larger.
 * 
 * The article and tag containers keep track of changes made to the 
 * contents of the workspace (see `Container` for more information).
 * When a workspace is opened, the `workspaceModified`-listener is 
 * attached to each container. This listener is called whenever the 
 * contents of the containers are modified triggering a saving event
 * where the workspace JSON is stringified and written into the `.asum`-
 * file. Once again, the entire JSON is written.
 */
export default class WorkspaceManager {

  /**
   * Constructs a `WorkspaceManager`-instance with the default settings.
   */
  constructor() {
    /**
     * The article container.
     */
    this.articles = null;

    /**
     * The tag container.
     */
    this.tags = null;

    /**
     * The next unique number that will be generated by the ID-counter.
     */
    this.idCounter = 0;

    /**
     * The name of the workspace.
     */
    this.workspaceName = "";

    /**
     * The file path of the workspace.
     */
    this.workspacePath = "";

    /**
     * Whether a workspace is open at the moment.
     */
    this.isWorkspaceOpen = false;
  }

  /**
   * Reads a given JSON and parses it returning 
   * the JSON.
   * 
   * @param {String} path File path of the JSON that is to 
   * be loaded.
   * 
   * @returns The parsed JSON.
   */
  loadWorkspace(path) {
    return JSON.parse(fs.readFileSync(path));
  }

  /**
   * Stringifies and writes a given JSON into a file.
   * 
   * @param {String} path Path of the file that the JSON is 
   * to be written into.
   * @param {JSON} workspace JSON that is to be written.
   */
  saveWorkspace(path, workspace) {
    const replacer = (key, value) => value ?? undefined;
    fs.writeFileSync(path, JSON.stringify(workspace, replacer, 2));
  }

  /**
   * Creates a new workspace and writes an empty workspace 
   * into a file at the given path. When the writing is complete, 
   * the workspace will be opened.
   * 
   * The path of the workspace will also be written into the 
   * ArticleSum. configuration file so that it will be opened 
   * next time the application is started.
   * 
   * @param {String} path File path where the workspace will be 
   * created.
   * @param {String} name The name of the workspace.
   */
  createWorkspace(path, name) {
    if( !path || !name || name === "" )
    return;

    this.workspacePath = path;
    this.workspaceName = name;
    this.saveWorkspace(this.workspacePath, Workspace(0, this.workspaceName));
    this.openWorkspace(this.workspacePath);
    editConfig({ lastWorkspace: this.workspacePath });
  }

  /**
   * Opens a workspace by loading it from a given file path.
   * The state of the workspace as outlined in its JSON will 
   * be stored in the `WorkspaceManager` and modification
   * listeners will be attached to the article and tag 
   * containers.
   * 
   * @param {String} path File path of the workspace that is 
   * to be opened.
   */
  openWorkspace(path) {
    if( !path || !fs.existsSync(path) )
    return;

    this.closeWorkspace();

    const ws = this.loadWorkspace(path);
    this.workspacePath = path;

    const notify = (changes) => this.workspaceModified(changes);
    const idRetriever = this.getUniqueId.bind(this);

    this.idCounter = ws["id-counter"];
    this.workspaceName = ws["workspace-name"];
    this.articles = new ArticleContainer(ws.articles, notify);
    this.articles.setIdRetriever(idRetriever);
    this.tags = new TagContainer(ws.tags, notify);
    this.tags.setIdRetriever(idRetriever);
    this.isWorkspaceOpen = true;
  }

  /**
   * Closes the workspace by resetting the state of the 
   * `WorkspaceManager`.
   */
  closeWorkspace() {
    this.articles = null;
    this.tags = null;
    this.idCounter = 0;
    this.workspaceName = "";
    this.workspacePath = "";
    this.isWorkspaceOpen = false;
  }

  /**
   * Posts changes to the workspace file by creating a new 
   * workspace JSON and writing it into the `.asum`-file.
   * 
   * The `changes` are provided as a `Container`-result 
   * -type JSON (see `Result` of `Container` for more 
   * information). This method is only concerned with the 
   * number of items affected by the change. If no items 
   * were affected, the workspace wont be saved.
   * 
   * @param {JSON} changes JSON containing the changes that 
   * were made to the workspace.
   */
  workspaceModified(changes) {
    if( changes.affectedItems.length <= 0 )
    return;
    
    const ws = Workspace(this.idCounter, this.workspaceName, this.articles.getItemArrayReference(), this.tags.getItemArrayReference());
    this.saveWorkspace(this.workspacePath, ws);
  }

  /**
   * Returns a reference to the article container that stores 
   * the article JSON of the workspace.
   * 
   * @returns Article container of the workspace.
   */
  getArticleContainer() {
    return this.articles;
  }

  /**
   * Returns a reference to the tag container that stores 
   * the tag JSON of the workspace.
   * 
   * @returns Tag container of the workspace.
   */
  getTagContainer() {
    return this.tags;
  }

  /**
   * Returns the file path of the `.asum`-file of the currently 
   * open workspace or "", if no workspace is open.
   * 
   * @returns File path of the workspace.
   */
  getWorkspacePath() {
    return this.workspacePath;
  }

  /**
   * Returns the name of the workspace.
   * 
   * @returns Workspace name.
   */
  getWorkspaceName() {
    return this.workspaceName;
  }

  /**
   * Returns whether a workspace is open in the `WorkspaceManager` 
   * currently.
   * 
   * @returns Whether a workspace is open.
   */
  checkWorkspaceOpen() {
    return this.isWorkspaceOpen;
  }

  /**
   * Returns a new unique identifier and increments the ID-counter 
   * number.
   * 
   * @returns A unique identifier for workspace content.
   */
  getUniqueId() {
    return "" + (this.idCounter++);
  }
}
